Запуск сервера: `yarn dev`
Запуск клиента: `yarn start`

СТЕК БЭК:

1. Node JS;
2. Express;
3. PostgreSQL;
4. Sequelize ORM;

ЧТО СДЕЛАЕМ:
1. Диаграмма бд;
2. Аторизация пользователя по JWT токену;
3. Полноценное REST API интернет-магазина;

СТЕК ФРОНТ:
1. React JS;
2. React bootstrap - графика (дабы не тратить время на верстку);
3. Axios - запросы к серверу;
4. React-router-dom - навигация по страницам;
5. MobX - стейт менеджмент;


СДЕЛАНО BACK:
  1. Устанавливаем библиотеки: 
    - express; 
    - pg; 
    - pg-hstore; 
    - sequelize; 
    - cors; (для обращения (отправки запросов) к браузеру с нашего сервера)
    - dotenv; (задавать переменные окружения)
    - express-fileupload; (устанавливается в корне server, используется для получения фото из тела запроса)
    - uuid; (генерация уникальных айдишников)
    - jsonwebtoken; (для генирации токена)
    - bcrypt; (для хеширования паролей и возможности не хранить их в бд в открытом виде)
    - cookie-parser; (для работы с корзиной)
    - yarn add @types/cookie-parser --dev; (к команде выше)

  2. Устанавливаем зависимость для разработки (-D): nodemon;

  3. Прописываем скрипты в package.json;

  4. Создаем базу данных и подключаемся к ней с помощью sequelize;
    ЗАМЕТКА: Методы Sequelize (create, update, save, destroy, reload, findOne, findByPk, findAll)

  5. Строим диаграмму БД в drawio и переносим ее в наш проект (папка models => models.js, где будут описаны модели бд);

  6. Создаем каркас нашего приложения и начинаем с маршрутизации. Создаем папку routes и отдельный файлы для типов, устройств, пользователей, корзины (в общем всех сущностей) 
    и index.js для объединения всех файлов внутри;

  7. На данный момент вся логика (функция) написаны в роутере. Это плохая практика и нужно вынести все это дело в отдельную директорию (controllers);

  8. Создаем отдельную папку error для обработчиков ошибок;

  9. Создаем middleware -> ErrorHandlingMiddleware.js
    ВАЖНО: мидлварь с ошибками должен быть зарегистрирован в файле исполнителе index.js(корень прилодения) - В САМУЮ ПОСЛЕДНЮЮ ОЧЕРЕДЬ

  10. Добавляем в БД объекты. 
    ВНИМАНИЕ! Полноценная валидация не реализована (только основа, чтобы работало. ДОБЫТЬ ИНФУ И ДОРАБОТАТЬ!)

  11. Создаем дирректорию static в корне server (в ней будут храниться все файлы с фото товара, отправляемые с клиента). После этого научим наш сервер отдавать эти файлы как статику;

  12. Устанавливаем лимит вывода товаров на одной странице;
    ЗАМЕТКА: чтобы посчитать кол-во страниц на фронте, нужно узнать общее кол-во товаров которое вернется нам по заданному вопросу. Для это нужно использовать функцию findAndCountAll() за место findAll(). (она предназначена для плагинации)

  13. Начинаем разбор регистрации пользователя;
    ЗАМЕТКА: для осуществления нормальной валидации смотри видео про аторизацию на ноде (userController.js -> (* ) (* ))

    ЗАМЕТКА: сайт для декодирования токенов (https://jwt.io/)

  14. Прописываем функцию логина пользователя;

  15. Перед созданием логики функции authorizationCheck() cоздаем middleware для декодирования токена и проверки его на валидность
    ЗАМЕТКА: Вся функция authorizationCheck() будет сведена к тому, чтобы сгенерировать новый токен и отправить его обратно на клиент (если пользователь постоянно использует свой аккаунт, то токен у него будет перезаписываться)

  На данный момент мы можем  добавлять бренды, устройства и типы, а также получать их, но это может сделать абсолютно любой пользователь.
  Нам нужно сделать так, чтобы обавить новый товар в магазин мог только администратор -> 

  16. -> checkRoleMiddleware.js

  17. Создана дирректория services с файлом File.js (отвечает за работу с файлами при передаче запросов на создание товаров с фото);

  18. Реализуем архитектуру MVC (model, view, controller) и для этого в дирректории models создаем файлы наших сущностей (Модели реализуют бизнес-логику приложеня и взаимодействуют через Sequelize); 

  19. После создания контроллера и модели deviceProp мы можем обновлять и доплнять св-ва товара, без участия сущности device

  20. Создаем корзину 

  21. В параметрах REST Client изменяем расширение запоминающее cookie ("rest-client.rememberCookiesForSubsequentRequests": false)

  22. Теперь разберемся с рейтингами товаров. Голосовать за товары могут только зарегистрированные пользователи. 
    Пользователь может проголосовать за товар только один раз. Рейтинг товара вычисляется как сумма оценок, поделенная на количество голосований. Как обычно, создаем новые маршруты, контроллер и модель. Методов у модели и контроллера будет всего два — проголосовать за товар и получить рейтинг товара.

  23. 

  ИТОГ: имеем REST API, сервер раздает статику (фото), мы можем регистрироваться, аторизовываться. 

СДЕЛАНО CLIENT:
  1. Разварачиваем React-приложение (npx create-react-app .)
    тут возникли проблемы с правами пользователя (предоставляем их для текущего с помощью sudo chown -R 502:20 "/Users/gilart/.npm")
  
  2. Устанавливаем зависимости: 
   - axios; (для отправки запросов на сервер)
   - react-router-dom; (для страничной навигации)
   - mobx; (state-manager - это инструмент или паттерн программирования, который обеспечивает управление состоянием приложения во время его работы. Он позволяет хранить, обновлять и синхронизировать данные между различными компонентами приложения.)
   - mobx-react-lite; (для связки mobx с функциональными компонентами react)
   - jwt-decode; (декодировать jwt)
   - ? history; пакет для работы с историей браузера ?
   - @babel/plugin-proposal-private-property-in-object;
   - react-uuid; ()

  3. Чтобы не тратить время на верстку будет использоваться bootstrap;
    Устанавливаем его (yarn add react-bootstrap bootstrap)
  
  4. public -> index.html добавляем стили; 

  5. Запускаем react приложение (yarn start);

  6. Создаем основные рабочие папки внутри src:
   - store; (для взфаимодействия с mobx и хранения данных)
   - pages; (в ней будут корневые компоненты, которые будут являться страницами)
   - components; (папка с компонентами)

  7. В pages добавляем страницы (pages) с:
   - авторизацией (Login.js); 
   - страница регистрации (Signup.js);
   - витрина магазина со списком всех товаров, постраничным выводом, списком брендов и т.д. (Shop.js); 
   - страница просмотра товара (Device.js);
   - администратор будет добавлять устройства, типы и все, что относится к его работе, в наш магазин (Admin.js);
   - страница с корзиной (Basket.js); 
   - страница контактов (Contacts.js);
   - страница доставки (Delivery.js);
   - страница, при неправильном указании пути (NoteFound.js);
   - страница пользователя? (User.js);

  8. Реализуем навигацию по созданным странцам приложения (components):
   - логика навигации по страницам (AppRouter.js);
   - логика расписывается для всех пользователей (публичный доступ, для авторизованных, для админов)
  
  9. Создаем компонет NavBar (в папке components);

  10. Создаем компонет AppContext (в папке components);

  11. Прорабатываем компоненты Signup, Login, Shop и Basket (верстаем);

  12. Библиотека axios позволяет перехватывать все запросы и ответы и применять к ним определенную логику. 
    Нам нужны два экземпляра axios — для запросов на сервер от любого посетителя сайта и для запросов от авторизованного пользователя. 
    Создаем директорию src/http и внутри нее — файл index.js.

  13. Примечание: все переменные среды в react-приложении должны начинаться на REACT_APP_

  14. Создаем src/store/UserStore.js. для управления состоянием с помощью MobX

  15. Автоматическая авторизация. (Если пользователь авторизовался, то в главном меню будут ссылки «Личный кабинет» и «Панель управления» (для администратора). 
    Если теперь перезагрузить страницу, то в главном меню будут ссылки «Войти» и «Регистрация». Потому что страница загружается с сервера и у приложения еще нет состояния — вызов new UserStore() в AppContext присвоит всем свойствам класса значения null и false.
      Такое положение вещей нас не очень устраивает, поэтому создадим HOC-компонент components/CheckAuth.js, который авторизует пользователя — при наличии в хранилище правильного токена.)

  16. Компонент User
    Отвечает за личный кабинет, там пока ничего нет, только добавим кнопку для выхода:

  17.  Хранилище каталога, компонент витрины, кнопка «Назад»
    Нам надо создать хранилище товаров с использованием MobX. Организовать загрузку с сервера списка категорий, брендов и товаров. Наконец, фильтровать список товаров при клике на категорию и/или бренд.
    - создаем файл http/catalogAPI.js для работы с каталогом товаров;
    - создаем хранилище состояния каталога store/CatalogStore.js;
  
  18. Компоненты CategoryBar и BrandBar
    При клике по категории и/или бренду — нужно изменить состояние хранилища, что приводит к рендеру компонента Shop

  19. Компоненты ProductList и ProductItem
    Нужно доработать компонент ProductList и добавить постраничную навигацию — при клике на номер страницы изменяем состояние, что вызывает новый рендер Shop.

  20. Нужно доработать модель на сервере server/model/Product.js, чтобы при получении списка товаров получать еще и бренд для каждого товара

  21. Произвели изменения на сервере (DeviceModel и DeviceController (экспериментальные обработсики getAll()))

  22. Реализуем функционал кнопок браузера 'Вперед' и 'Назад';

  23. Для работы с историей браузера можно воспользоваться библиотекой history, а можно с помощью useState(это хук, предоставляемый React, 
      который позволяет функциональным компонентам иметь внутреннее состояние.)
      - воспользуемся useState!
      
  24. Работаем над корзиной покупателя 

  25. Работа с заказами на сервере, оформление заказа
    - Сначала работаем на стороне сервера (Нам нужно на сервере создать две таблицы базы данных, создать маршруты и классы контроллера и модели. 
      Потом протестировать все http-запросы — на создание заказа администратором и обычным пользователем, на получение списка всех заказов и одного заказа администратором и пользователем. 
      Потом можно будет переходить на сторону клиента и создать форму для оформления заказа.)

ВНИМАНИЕ!! не слишком удачно у меня получилось с пользователем и корзиной. Запрашивать данные о пользователе и корзине лучше в компоненте App, потому что эти данные много где требуются — например, в компонентах NavBar, AppRouter, Checkout. А сейчас получается, что надо их получать дважды — сначала в NavBar, а потом еще в Checkout.
  
  26. Личный кабинет, список заказов и отдельный заказ
  ПРИМЕЧАНИЕ1: Здесь много что можно сделать — история заказов в магазине, профили для удобного оформления, изменение пароля, избранные товары. Но мы ограничимся только историей заказов — а то конца и края не видно с этим магазином. 
  ПРИМЕЧАНИЕ2: Компоненты Order.js и Orders.js можно было и не создавать, а показать список заказов и отдельный заказ прямо в компонентах UserOrders и UserOrder. Но они нам потребуются при разработке панели управления для администратора магазина, потому что там тоже нужно показывать список заказов и отдельный заказ.
  
  27. Редактируем формат даты заказа (server/models/mapping.js -> Order (добавляем 2 виртуальных поля prettyCreatedAt и prettyUpdatedAt — которые будут брать значение createdAt и updatedAt и форматировать под наши потребности))

  28. Панель управления: список заказов, категорий и брендов
    - Добавляем переменную change в AdminCategories - и будем изменять ее значение после создания новой категории (все делается для автоматического обновления списка типов товара)
    - Нужно добавить возможность редактирования и удаления категорий и брендов. Для этого создадим компоненты UpdateCategory.js и UpdateBrand.js. Этим компонентам нужны функции fetchCategory и fetchBrand, которые должны быть в файле http/catalogAPI.js — но их там не оказалось. Так что с этого и начнем
    
  29. Рефактринг 
  
========================================================================

